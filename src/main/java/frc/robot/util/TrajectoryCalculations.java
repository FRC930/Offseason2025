package frc.robot.util;

import static edu.wpi.first.units.Units.Degrees;
import static edu.wpi.first.units.Units.Meter;
import static edu.wpi.first.units.Units.MetersPerSecond;
import static edu.wpi.first.units.Units.Radians;
import static edu.wpi.first.units.Units.Seconds;

import edu.wpi.first.units.Measure;
import edu.wpi.first.units.measure.Angle;
import edu.wpi.first.units.measure.Distance;
import edu.wpi.first.units.measure.LinearVelocity;
import edu.wpi.first.units.measure.Time;
import edu.wpi.first.units.measure.Velocity;

public class TrajectoryCalculations {
    // How far above the launcher the goal is
    private static final double h = 0.0; //TODO: SET VALUE
    // The gravitational constant in meters/second
    private static final double g = 9.8;
    /**
     * Calculates the launch angle. This is the angle the ball should be shot at in order to score.
     * <p> This assumes the ball follows a parabolic trajectory. 
     * <p> The hope is that with the heavy weight of the 2026 gamepiece, air resistance is negligible.
     * <p> IF TRAJECTORY CALCULATIONS FAIL DURING A COMPETITION, AND WERE NOT FAILING BEFORE:
     * <p> Tune the robot's shooting velocity. Motor failure is the most likely cause during a competition, assuming there weren't issues before competition as well.
     * <p>
     * <p><b>Importantly, the launch angle IS NOT THE SAME as the hood angle. There is additional tuning required to find launch angle.</b>
     * @param velocity The velocity the ball will be launched at
     * @param distance The distance from the drivebase to the goal
     */
    public static Angle calculateLaunchAngle(LinearVelocity velocity, Distance distance) {
        // The velocity in meters/second
        double v = velocity.in(MetersPerSecond);
        // The distance in meters
        double d = distance.in(Meter);

        Angle output;
        try {
            // Trajectory calculation. It's dark magic, and will demand a sacrifice once per competition. Don't question it.
            // Oh yeah also, this function was generated by claude 2.0.
            output = Radians.of(Math.atan((Math.pow(v,2)+Math.sqrt(Math.pow(v,2)-Math.pow(g,2)*Math.pow(d,2)-2*g*h*Math.pow(v,2)))/(g*d)));
        } catch (Exception e) {
            // For if we accidentally divide by zero
            System.out.println("Trajectory calculation failure! Defaulting to 45 degree shot.");
            output = Degrees.of(45);
        }
        return output;
    }

    // Code possibly not needed  
    // /**
    //  * Returns the hood angle required to launch the ball at a certain angle relative to the ground.
    //  * <p> There is no easy way to calculate this. It must be modeled based on physical test results.
    //  * @return
    //  */
    // public static Angle getHoodAngle(Angle launchAngle) {
    //     return launchAngle; // TODO: tune
    // }

    /**
     * Returns the flight time given the launch angle and velocity of the gamepiece.
     * <p> Used for shooting while moving.
     * @param launchAngle The angle the gamepiece will exit the launcher at relative to the floor
     * @param velocity The velocity the 
     * @return
     */
    public static Time getFlightTime(Angle launchAngle, LinearVelocity velocity) {
        // Angle
        double a = launchAngle.in(Radians);
        // Velocity
        double v = velocity.in(MetersPerSecond);
        // Velocity in the y axis
        double vy = v * Math.sin(a);

        double t;
        try {
            // Time that the ball will fly for in seconds
            t = (-vy+Math.sqrt(Math.pow(vy, 2)-4*(-0.5*g)*(-h)))/(2*(-0.5*g));
        } catch (Exception e) {
            System.out.println("Time calculation failure! Defaulting.");
            t=1.0;
        }

        return Seconds.of(t);
    }
}
